1. Searching Algorithms

Used to find elements in a data set.

    Linear Search – Checks each element one-by-one.

    Binary Search – Efficient search in a sorted list (O(log n)).
    
2. Dynamic Programming Algorithms

Used for optimization problems by breaking into subproblems and storing results.

    Fibonacci sequence

    Knapsack problem

    Longest Common Subsequence (LCS)

    Matrix Chain Multiplication

    Coin Change Problem
    
3. Graph Algorithms

Used for problems related to networks, paths, and relationships.

    Depth-First Search (DFS)

    Breadth-First Search (BFS)

    Dijkstra’s Algorithm – Shortest path from one node to all others.

    Bellman-Ford Algorithm – Shortest paths with negative weights.

    Floyd-Warshall Algorithm – All-pairs shortest paths.

    Kruskal’s Algorithm – Minimum spanning tree.

    Prim’s Algorithm – Another MST algorithm.
    
4. Greedy Algorithms

Makes the locally optimal choice at each step.

    Activity Selection Problem

    Huffman Coding

    Fractional Knapsack

    Dijkstra’s Algorithm (also fits here)
    
5. Backtracking Algorithms

Explores all possibilities by building solutions incrementally and abandoning paths that don’t work.

    N-Queens Problem

    Sudoku Solver

    Maze Solving

    Subset Sum Problem
    
6. Brute Force Algorithms

Try all possibilities; simple but inefficient.

    String matching (e.g., password guessing)

    Travelling Salesman Problem (TSP)

    Permutations/combinations generator
    
7. Divide and Conquer

Solves problems by dividing into subproblems.

    Merge Sort

    Quick Sort

    Binary Search

    Strassen’s Matrix Multiplication